    先说总骨架。首先，如果只要求最后一个数最小，那是很好办的，DP一下就可以。我们设最后一个数为max。确定了max以后，接着从大到小枚举第一个数，显然第一个数要大于0并小于max，设其为min1，然后再割掉max以及min1，看剩下的数字能否构成一个递增数列，并且里面所有数值都满足大于min1，小于max。如果能，那就把第一个数确定下来，然后枚举第二个数，记为min2，继续以上操作，直到整个数列都被取光为止。
    然后再讲下DP。开了个数组ok，ok[i]表示是否可能在第i个数后面分段。还有数组f，如果ok[i]=1（也就是说，可能分段），那么f[i]里存的就是最后一段的最小值。对于原串的某一段[l..r]，令ok[l-1]=1，f[l-1]=min（min为当前下界）。然后用i从前到后枚举l..r，再用一重循环j枚举1..i-l+1，分别表示当前段的末尾位，以及当前段的长度。然后看ok[i-j]是否可能，如果是再看当前段是否比f[i-j]大，两者缺一就不处理当前段，否则把ok[i]赋成1，令f[i]等于当前段。
    DP完以后，就是根据结果判断它是否能跟min和max匹配。原来的想法是，如果max是从第k位到结束，那就看ok[k-1]，如果等于1的话就可以，否则不行。但样例就把这个想法否决了。因为数字的前导0问题。当时想到出了身冷汗，后来想到，这种情况，只要看从k-1往前一直到第一个遇到的非0数中，是否有一个ok[i]=1。如果有，就可以。
    比较长度有点小烦...这次我是正着存的。但除了考虑全0而导致的位数为0的问题以外，也没有什么大问题了。