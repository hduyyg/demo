    开两个二维数组，min和f。min[i][j]表示，如果第i个到第j个居民点共用一个服务机构，所需要的最小花费。f[i][j]表示，建立j个服务机构，满足前i个居民点的服务需求的话，所需最小花费。再用一个一维数组tot，tot[i]表示从第1个到第i个居民点的总人口数。
    f[i][j]的递推式相对简单：f[i][j] = min{f[i - k][j - 1] + min[k + 1][i]}，当然得特殊处理j = 1的情况，因为f[i][0]是不合法的。
    min[i][j]就罗嗦一点了。显然，i == j的时候，min[i][i]就等于在这个点建立服务机构的费用。不难证明，倘若把当前区域向后扩展一个居民点，为了达到最小花费，服务机构所在的居民点编号只可能增大。于是再开两个变量pos和best，pos表示当前段中服务机构所在的居民点编号，best则是当前段的最小花费。每次把当前区域向后扩展一个居民点，从min[i][j]扩展成min[i][j + 1]，此时min[i][j + 1]的值就是best + (len[j + 1] - len[pos]) * val[j + 1]，其中len[i]表示第i个居民点的坐标位置，val[i]表示第i个居民点的人口数。
    然后尝试把pos向后移。注意，可能出现pos往后移一格会使总花费增加，但移两格就能使总花费减少的情况。所以要枚举所有的移动可能。但我们仍然可以一格格地移。每移一格，在处理范围内，且编号小于等于pos的居民点，总花费增加它们的总人口*两格间路程，而编号大于等于pos的居民点，总花费是减小。总花费可以直接根据tot数组，在O(1)的时间内求得。枚举完后，在f[1][1]~f[1][m]间取一个最小的输出。