    题目刚拿到手时可真让人浮想联翩呵~本来想用f[i,j,k]表示前i个人完成j个A模块（我把A程序的一个模块简称一个A模块，B的类推）以及k个B模块时所需的最少时间，后来发现递推公式好象不是很好弄，而且就算弄出来转移也得是平方级的，总复杂度就是O(n^5)，对付n最大到100的数据非死不可……
    然后想到既然天数难处理那不妨二分天数（这点好多同志都想到了）。接下来的处理，本来想弄个猥琐的贪心，就是先调集做A程序速度快的人把A程序先切掉，然后看他们与此同时还能切掉多少个B程序里的模块，如果没法完成任务再调整。在拿样例模拟的时候突然想到，如果一个人做的A模块的数目定下来后，他做B模块的数目在天数确定的情况下不也就确定了么。于是觉得可以把原来想到的f[i,j,k]里k的那一维省下来~也就是说，只枚举人数以及完成A模块的个数。
    最终的想法是这样：先二分天数，对于当前的总天数d，用f[i,j]表示d天内，前i个人完成j个A模块后，最多能完成多少个B模块。不妨设第i个人完成A、B模块的速度分别为Ai、Bi，于是动态方程就是：
f[i,j]=max{f[i-1,j-k]+(d-k*Ai) div Bi}(0<=k<=d div Ai)，也就是说，枚举第i个人做的A模块的数目，取一种能让B模块完成总数最大的方案。需要枚举的是i，j和k，于是复杂度显然是O(n^3)。再乘上二分天数的O(log n)，总复杂度就是O(n^3 log n)。而且这是最坏情况下的复杂度，一般随机数据都远远达不到极限。当然，最让我满意的是，这个想法简洁清晰得很，于是程序写得不是一般的爽~
    最后结果嘛，呵呵，当然是AC了~咔咔，难得写到效率全场最高的程序~
    对了补充一句，如果DP题里有2个或多个变量在确定了某一个后就可以推出其他几个，那就只要枚举一个，其他的用类乎这个题的算法来降维。


更简单的：只要先贪心一个上界，然后按照n^5的方法做，每次更新上界就可以过了。
