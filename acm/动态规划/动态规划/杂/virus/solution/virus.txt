    这个题目是标准的dp。考场上其实也写的八九不离十了，结果就因为没有再看一遍，把处理'*'的地方写错了一点，于是只有3个点...555...这次也只是在记事本里改了一点就AC了，但没有上次改好那个敲砖块的题目那种激动...经常出现这种情况只能说明我自己有问题。要改。
    又罗嗦了这么多...-_-b开始讲算法。
    如果没有'?'和'*'的话，这个题目就是KMP。但多了这两个符号，它的算法就得改成dp了...于是用ok[i,j]表示在病毒模版片段里的前i个字母能否在当前处理的RNA片段中找到与之匹配的片段。并且，这个片段的最后一个元素就是当前RNA片段中的第j个元素。（ok[i,j]=0表示不可能，否则为可能）
    当然，事先把所有的ok[0,j]都赋成1。也就是说，不取模版片段中的字母的话，总是能匹配上的。
    如果病毒模版片段的第i个元素就是正常的字母，并且那个字母与当前RNA片段中的第j个字母相同，显然ok[i,j]:=ok[i-1,j-1]。否则ok[i,j]:=0。
    如果第i个元素是'?'，那么直接ok[i,j]:=ok[i-1,j-1]。因为在比较时它与RNA片段中的任何字母都是相等的。
    如果第i个元素是'*'，就麻烦一点。我一开始写错的原因，是以为只要出现'*'，那么ok[i,j]无论j取什么值，总是可行的。而实际上，只有在当前RNA片段的前k个能跟模版片段的前i-1个匹配上时，才能用'*'代替第k到第j个字母。所以，ok[i,j]:=ok[i-1,j] or ok[i,j-1]，也就是说，如果少用一个当前片段的元素仍然可行，那让'*'再多代表一个元素并没有妨碍；如果这种情况不成立，但当前j个字母能与模版串的前i-1个元素匹配上，那就让'*'代表一个空串，于是这种情况也是可行的。
    最后，如果模版串的长度为len，那就扫描一下所有的ok[len,j]，如果情况可行，那这个RNA序列就是病毒。若找不到，说明不是。
    以后在考场上，如果下决心写某个程序，就一定要好好测试。光求数量不求质量是不行的，当然也别太过苛求。一般dp题等算法类的，要好好测，但搜索这种用来混分的，就可以稍微轻视一点，除非写它的目的并不是用来混分。

P.S.
    为什么到TOJ上交就TLE了呢...要再优化下。