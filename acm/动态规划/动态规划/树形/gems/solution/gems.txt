    第一次看到这题想贪心，但似乎没法处理很多恶心的情况...这次是用树形DP写的。事实上，如果题目中说明了最多有s种宝石，dp方程应该不难想：用opt[i, j]表示，在dfs树中，以第i个结点为根的子树，如果第i个点选用第j种宝石，那么这棵子树的最小花费是多少。因为相邻结点不能选用相同的宝石，于是opt[i, j] = min(opt[son1, k]) + min(opt[son2, k]) + ...，其中son1、son2是i的儿子的编号，k取值为1~s间不等于j的数。
    然而题目中没有给出一个明确的s。但我们可以设一个宝石总种数。记得当年是cmc告诉我，s为9就可以了。今天写完后，对着数据改s的取值，发现s只要等于3，也就是说只要3种宝石，就可以完成任务。至于为什么，我没有想明白。