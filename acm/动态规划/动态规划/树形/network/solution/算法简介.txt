本题可采用树形动态规划算法，首先任选一个结点(不妨选结点1)作为根结点将输入数据构造成一棵n叉树，将每条边上的铺设方案(d↓/c↑表)存放在这条边连接的父子两结点中的子结点中，根结点中不存放d↓/c↑表，同时每个结点还存放结点编号等信息。由于树有着良好的递归性质，所以只要考虑一层的情况，即一个父结点f和它的若干个子结点son[i]的情况，每个子结点son[i]存放的d↓/c↑表在这里已不是连接son[i]和f的那条边上的铺设方案，而是整棵son[i]为根的子树(包括连接son[i]和f的那条边)上的d↓/c↑表，即要将整棵子树铺设好且总延时不超过d的最小总费用c组成的总表，生成这一总表的方法是先对兄弟进行归并，再将归并的结果(也是一个d↓/c↑表)与f结点的d↓/c↑表迭加。兄弟归并的思想是将所有兄弟结点中的每个d按从大到小的次序并入一个表(程序中用merged记录)，对每个d计算最小的总费用记录在mergec中，这一过程与归并排序十分相似，需要注意的是当当前的d>limittime div 2时，不可简单将各表头元素(h[i]指向的，各兄弟中未并入merge表的最靠前的元素)的c相加作用d的总费用，这样会造成两点之间的总延时超过limittime，程序中引入t[i]指向第i个兄弟的当前延时+d<=limittime的最靠前的元素(越靠前的元素c越小，方案更优)。可以看出这一归并过程在保证局部任意两点之间的总延时不超过limittime的前提下，子树上所有结点到f的延时不超过d时铺设好整棵子树的总费用mergec一定最小，这样就将一棵子树浓缩成一个结点的情况，可以很好地从下向上递归求解了。迭加采用了简单穷举，相当于将两条边(呈链状)铺设好，求各种d下的最小总费用。