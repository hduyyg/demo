    写的好累...这题跟贪吃的九头龙，在方程上是有本质区别的，但我一开始居然就一样地写了...于是...
    首先，树形DP，如果用左儿子右兄弟的话，它的DP单位不是某棵子树，而是，一棵子树，加它的父亲。
    用f[i,j,k,l]表示，当前结点为i，以及它的子树和父亲构成的一棵树中，一共有j条边被选中，i的状态为k，j的状态为l时，最大能得到的产奶量。其中k,l为0或1，0表示没有选中该点。
    递归执行操作，对于给定的root,i,j，开4个变量，bigl0,bigl1,bigr0,bigr1。bigl0表示，结点root的状态为0的话，它与它的左子树中有j条边的情况下，产奶量最大是多少。后面的类推。bigr0只要把边数换成i-j。
    于是，很显然，f[root][i][0][0] = bigl0 + bigr0，f[root][i][0][1]和f[root][i][1][0]也一样。f[i][j][1][1]要特殊处理一下，因为此时左右两子树里的边总数是i-1而不是i。
    然后还有个细节：f[root][0][i][j]（i,j取值为0或1）都为0，但，如果root结点没有左子树，那么，bigl1就应该等于root结点的权值，而不是0；bigr1也这么处理。
    因为这个图可能是个森林，于是把它们加上一个超级根：结点0。输出的时候，只要在结点0的左孩子a的记录里查找，从大到小枚举max，如果发现f[a][max][i][0]大于等于要求的数，就输出max。